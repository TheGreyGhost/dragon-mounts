High-level description of breath weapon code
There is minimal communication between the client and the server.

Client sends the current target (eg entityID) to the server, which keeps track of all players' targets and sends them to other clients (via DataWatcher on the corresponding dragon entity) when the dragon starts breathing. That's the only network traffic related to the breath weapon, i.e. ranging from ten bytes per second to a few hundred bytes per second.

The spawning of EntityFX on the client is done locally based on the DataWatcher target.
The collision calculations between the breath weapon and nearby blocks+entities are done by the server and the results (damage etc) are synchronised to the clients by vanilla; but there is no Entity or EntityFX information exchanged between the two. The collision calculations themselves have a couple of basic optimisations to speed them up.

Briefly how it works:
On client:
DragonOrbControl monitors user input and sends a DragonTargetMessage to the server when the player's target has changed.

On server:
Receives DragonTargetMessage, caches the corresponding BreathWeaponTarget locally (in DragonOrbTargets)

DragonBreathHelper then uses AI to move the dragon to an appropriate range and to start breathing when ready - the breathing target is sent to nearby clients using a DataWatcher on the dragon.

Back on client:
DragonBreathHelper for each each dragon retrieves the current target from the DataWatcher, then spawns the breath using
BreathWeaponEmitter, which creates a stream of FlameBreathFX for rendering & collision, each with a corresponding BreathNode to model the size, aging, power etc of each FlameBreathFX.

Meanwhile on the server, the effects of the breath weapon are modelled by creating a stream of EntityBreathNodes with corresponding BreathNodes, similar to the client. (The EntityBreathNodes are not spawned, just stored in a collection). Collision detection is performed between the EntityBreathNodes and the blocks and nearby entities - once a block or entity has suffered enough collisions with nodes, it takes damage / gets smelted / etc.
The main classes modelling this are DragonBreathHelper, BreathWeapon, BreathNode, EntityBreathNode, BreathAffectedBlock/Entity
The collision detection is in BreathAffectedArea and NodeLineSegment.

Adding new types of breath is intended to be done by overriding
BreathWeapon,
BreathWeaponEmitter, with different equivalents for FlameBreathFX.
BreathNode
but not all the classes implement this fully yet (for example, BreathAffectedArea will need to use BreathWeapon to spawn BreathNodes with the correct speed and size; BreathNode is currently hard-coded values).

Pretty much all the other changes to the code are related to making sure the breath weapon nodes spawn from the dragon's mouth - which is affected by yaw and pitch and size etc - so I moved the positioning code into a common class for both server and client. That was pretty fiddly to get right.

bugs:
OK dragon breed command doesn't alter the breath weapon


Still to do:
OK document code structure
OK strip out debugging
OK sound of flame
OK dragon sounds roar juvenile
OK test with built version; dedicated server version
OK- breath effect on entities
OK- breath effect on blocks
OK- dragon should not burn itself
OK dragon breath position not correct when hovering
OK ignore click on block
OK small breath beam still hits player who is nowhere near
OK after a flammable block takes enough damage, destroy it (rain puts out fire)
OK zoom out view when in 3rd person
OK dragon loses height when flying
OK? hatchling repeatedly opens & closes mouth when trying to breathe

OK HeadPositionNumbers on client & server don't match up.

later
- different breath types
- dragon can fly around without rider
OK change to configuration screen
OK visual targeting indication
OK breath immunity for player holding orb? for rider
- add flying motion vector to breath vector?
- aiming is awkward when riding the dragon.
- make dragon partially transparent when being ridden
- bug fix: dragon doesn't swim
OK bug fix: dragon disappears when still inside field of view

---------------
BreathWeapon types:
Air-
Gusts of strong wind to buffet mobs and shred scenery (make it fly away?). blow away items the player is holding

Ender-
Purple fireball as per Xbox version?

Fire-
Already done

Forest-
Acidic gas cloud green

Ghost-
Electricity

Ice-
Ice shards / similar to sleet in game

Water
Generates water - washes player with; generates water

Nether
Fireballs as per ghast


----------

** have to exclude test sources in order to build properly - tests won't execute during build.

DataWatcher usage:
see http://wiki.vg/Entities#Entity_Metadata_Format
Entity
0 = STATUS byte = 0
   Known flags: 0) is burning; 1) is sneaking; 2) is riding something; 3) is sprinting; 4) is eating
1 = AIR short = 300 amount of air / breath
2 = CUSTOM NAME TAG string = ""
3 = ALWAYS RENDER NAME TAG byte = 0
4 = SILENT byte = 0, 1 = silent

EntityLivingBase
6 = HEALTH float = 60.0
7 = int = 0  Affected by a potion, contains the colour of the effect
8 = byte = 0  EnumParticleTypes.SPELL_MOB_AMBIENT vs EnumParticleTypes.SPELL_MOB  - beacon effects vs other effects?
9 = byte = 0  Number of arrows stuck in entity

EntityAgeable
12 = JUVENILE/ADULT flag byte = -1

EntityLiving
15 = AI enable/disable byte = 0

EntityTameable
16 = TAMED_FLAGS byte = 0;
     4 = tamed?
     1 = sitting?
17 = OWNER_ID string = ""

DragonMounts
18 = INDEX_FLYING byte = 0
19 = INDEX_CAN_FLY byte = 0
20 = INDEX_SADDLED byte = 0
21 = INDEX_BREEDER string = "Player63"
22 = INDEX_BREED string = "ghost"
23 = INDEX_REPRO_COUNT integer = 0
24 = INDEX_TICKS_SINCE_CREATION short

breath weapons
fire
lightning
fireballs
ice/snow

thoughts-
could use an entityemitter with breath aiming info
or alternatively just packets (server sends regular updates on breath beam position to clients)
or - always use dragon head pos, pitch, & yaw (or aim point) for beam origin rendering?

spawn EntityFX as per vanilla?  or just use custom rendering based on breath beam?

packet might be
timestamp (byte)
entityID
origin [x,y,z] in packed format, 2 bytes per axis (say - lsb is the fractional position, msb is the world position, snap to
   entity position)
yaw and pitch, both as short
Datawatcher instead?

smooth out any jerks in aiming position?

Want it to look best from the client who is controlling the dragon
-Will be best to tie the origin to the dragon's head always, also the aim.  Collision checks on client for rendering
--> send to the server where the player thinks the beam is starting & aiming
--> server performs sanity check but otherwise trusts the client information.  Does collision checks etc itself
--> server sends to other clients in step with entity info.  client renders with beam bound to head, uses aiming direction from
    server.

On client side: spawn EntityFX
On server side: dragonentity keeps track of the breath location over time- eg each tick adds another sphere coordinate
  to a list, updates position of all, tracks them until they die.  Create a list of all touched blocks, for each one which
  is a block, burn it.  Sustained contact for a long time does smelting (eg sand to glass).  Other breaths do other
  effects, eg freezing to break blocks, skeletal dragon kills living things (turns to dead bush?) etc.

BreathAffectedArea base class
- generated by BreedHelper
- stores the area of effect; called every tick with the breathing direction; applies the effects of the breath weapon
- derived classes for each type of breath
Ctor
- update (not breathing) or update(start, finish)
- affectBlock for each block
- affectEntity for each entity

The breathweapon is made up of a number of discrete BreathNodes which
BreathNode represents the age, size, and initial speed of each node;
The position, speed, and collision detection are tracked in an Entity:
EntityFX (FlameBreathFX) on the client - also does rendering changes
EntityBreathNodeServer on the server - also creates breath effects on the server world

There is fairly tight coupling between BreathNode and the Entity, because EntityBreathNodeServer can't extend EntityFX.
The common modelling behaviour on client and server is hence in BreathNode and Entity.

The dragonbreathhelper on the server creates a stream of EntityBreathNodeServer in BreathAffectedArea

------------------
need head position
Each model part has:
  rotationPointX, Y, Z and rotateAngleX Y Z
  offsetX, Y, Z  - always zero?

It appears that rotation is done without translate, from body 0,0,0

            model.neck.rotateAngleY = MathX.toRadians(lookYaw) * vertMulti * speed;  vertMulti = 1 for head

        model.head.rotateAngleX = MathX.toRadians(lookPitch) + (1 - speed);
        model.head.rotateAngleY = model.neck.rotateAngleY;
        model.head.rotateAngleZ = model.neck.rotateAngleZ * 0.2f;


head: rotPtX = 0, rotPtY = -2.389, rotPtZ = -34.9967

strategy for locating the head:
store HeadLocation in the EntityTameableDragon.  On client side, update HeadLocation from the head model part.
On server side, when a control packet for breath is sent from the client, include a vector for the head offset from
the dragon position - which is modified by the yaw on the server.  Also send a target point vector

-------------
Checking EntityFX path and effect of size change on path
1) without changing scale - flies straight
2) changing particleScale but not calling setSize - flies straight
3) changing particleScale and calling setSize while not flying - render position moves
4) changing particleScale and calling setSize while not flying, and moveEntity by half of width - no problem.

Changing particle size -> doesn't move left edge, so centre moves at half of width increase
--> must decrease by half the width increase?

5) changing width and height fields no effect when not moving
6) changing width and height fields, and setEntityBoundingBox, -> entity moves a long way.?

Weird stuff.  Just set a suitable initial size and leave it.  vary particleScale only.

Fixed.  Changing ABBB doesn't recentre properly, did it manually.

---------------------
Strategy for breath weapon:
When mounted, hold RMB down and use mouse to aim
- sends network message repeatedly with aiming point and throat position relative to body
- server receives message, sends messages to other clients including target location
- server burns blocks as per:
On client side: spawn EntityFX from head towards target point; rotate head to point.
On server side: dragonentity keeps track of the breath location over time- eg each tick adds another sphere coordinate
  to a list, updates position of all, tracks them until they die.  Create a list of all touched blocks, for each one which
  is a block, burn it.  Sustained contact for a long time does smelting (eg sand to glass).  Other breaths do other
  effects, eg freezing to break blocks, skeletal dragon kills living things (turns to dead bush?) etc.

Dragon animation has head tilt back and jaw open, takes perhaps half second

Dragon aiming is by holding a dragon orb and pointing and holding down RMB (blocking like a sword).

1) local animation is by dragon AI or by player with orb.
   living update checks for change in orb status.
   Sends message to server with breath on/off (control message)
   Includes aiming point (relative to player position and head rotation) and dragon head offset (position and rotation)
   Only update (say) 4x per second
2) server receives msg, forwards to other clients, also sets datawatcher
3) client checks datawatcher


Dragon fire animation is by bit 4 of datawatcher 0 to turn breath on/off

Head pitch and yaw will match the breath weapon target.  Delay?

Moving to within range of target and turning to face it and looking at it is done by the AI.

For breathing: head animation and turning is done by the Entity.


-------------
Targeting:
EntityAITargeting - keeps track of which entity or block is being targeted, controls dragon movement to an appropriate point
  and when it is within position, calls Entity.
  Don't move too close.

On originator client, EntityAITargeting info is copied from DragonOrbControl by the entity update tick - stored in Entity
On server, DragonOrbTarget (from network message sent from DragonOrbControl) - stored in Entity
On other clients, DragonOrbTarget (from datawatcher) - stored in Entity

Entity: startBreathing, stopBreathing, setTarget
  --> defers to the BreathWeaponStateMachine which as
    IDLE, STARTING, SUSTAIN, STOPPING to control animation
    client side EntityFX
    server side burning etc
If target is updated during SUSTAIN: if angle is small, keep burning.  if angle is large, interrupt.

EntityAITargeting controls head yaw & pitch

---------------
rotationYawHead = angle of the head in global angle CRS
renderYawOffset = angle of the body in global angle CRS
rotationYaw = body angle but not sure what the diff with renderYawOffset is.
EntityBodyHelper:
when entity is moving, snap renderYawOffset to rotationYaw and constrain head to within +/-75 of renderYawOffset
when entity is not moving, slowly realign body (renderYawOffset) to head rotationYawHead

EntityLookHelper:
rotates yaw and pitch to target position when looking
rotates yaw back to renderYawOffset when not looking.
constrain to +/-75 of renderYawOffset

--------------------
Refactoring of breathing AI:
EntityAIRangedBreathAttack as targeting AI
 - breathes if distance, angle, etc are correct
 -  if range too close for too long, change to bite.
 -  sets flag in entity for moveToCorrectTargetDistance
 - sets target to move to -
    if on ground - move to target separate AI
    if riding on ground or air - no effect
looking is handled by movement AI.
----------------------












